---
layout: default
permalink: /docs/built-in-extensions/
docs: true
---
<div class="main-margin left"></div>
<main id="docs">
  {% include docs_nav.html %}
  <section id="docs-content">
    <h1>Built-in extensions</h1>

    <p>Tuft comes with a few built-in extensions as named exports. When you import a built-in extension, you are
      importing a factory function that must be called to return the extension itself.</p>

    <h3 class="docs-sub-heading">Pre-handlers</h3>

    <div class="api-entry">
      <h3 id="search-params"><code>createSearchParams()</code></h3>
      <p>Adds a <code class="code-inline">searchParams</code> property to the request object, set to an instance of
        <code class="code-inline">URLSearchParams</code>, which contains any key/value pairs present in the query string
        of the request URL.</p>
      <pre><code class="language-js">const { createSearchParams } = require('tuft')

const app = tuft({
  preHandlers: [createSearchParams()]
})

app.set('/', t => {
  console.log(t.request.searchParams)
})

// A request for the path '/?foo=bar' will set 'searchParams' to the following:
// URLSearchParams { 'foo' => 'bar' }</code></pre>
    </div>

    <div class="api-entry">
      <h3 id="cookie-parser"><code>createCookieParser()</code></h3>
      <p>Extracts key/value pairs from the cookie header and makes them available as the
        <code class="code-inline">cookie</code> property in the request object.</p>
      <pre><code class="language-js">const { createCookieParser } = require('tuft')

const app = tuft({
  preHandlers: [createCookieParser()]
})

app.set('/foo', t => {
  console.log(t.request.cookies)
})</code></pre>
    </div>

    <div class="api-entry">
      <h3 id="body-parser"><code>createBodyParser(type [, maxSize])</code></h3>
      <p>By default, Tuft does not include the request body in the request object, as doing so has a significant
        performance impact. <strong>Body parser</strong> is therefore provided as an optional pre-handler extension that
        can be added only to the routes that require it. If a request includes a body that matches the provided <code class="code-inline">type</code>, then the parsed body data will be added to the request object as <code class="code-inline">body</code>, unless the request body size is greater than that of the provided <code class="code-inline">maxSize</code>.</p>
      <pre><code class="language-js">const { createBodyParser } = require('tuft')

const app = tuft({
  preHandlers: [createBodyParser('json')]
})

app.set('/', t => {
  console.log(t.request.body)
})</code></pre>
      <p>The <code class="code-inline">type</code> argument can be any of the following:</p>
      <div class="api-entry">
        <h3><code>'raw'</code></h3>
        <p>If the request content type is <code class="code-inline">'application/octet-stream'</code>, the body will be parsed as a <code class="code-inline">Buffer</code> object.</p>
      </div>

      <div class="api-entry">
        <h3><code>'text'</code></h3>
        <p>If the request content type is <code class="code-inline">'text/*'</code>, the body will be parsed as a <code class="code-inline">string</code>.</p>
      </div>

      <div class="api-entry">
        <h3><code>'json'</code></h3>
        <p>If the request content type is <code class="code-inline">'application/json'</code>, the body will be parsed as an <code class="code-inline">object</code> using <code class="code-inline">JSON.parse()</code>.</p>
      </div>

      <div class="api-entry">
        <h3><code>'urlEncoded'</code></h3>
        <p>If the request content type is <code class="code-inline">'application/x-www-form-urlencoded'</code>, the body will be parsed as an <code class="code-inline">object</code>.</p>
      </div>

      <p>The optional <code class="code-inline">maxSize</code> argument sets the maximum body size that can be parsed. Request bodies of a greater size will be ignored. If not set, defaults to <code class="code-inline">1048576</code> bytes (1 MiB).</p>
    </div>

    <h3 class="docs-sub-heading">Responders</h3>

    <div class="api-entry">
      <h3 id="stream-responder"><code>createStreamResponder()</code></h3>
      <p>By default, Tuft only supports sending a single "chunk" of data as the response body, even if that chunk itself ends up being split into smaller chunks by the the underlying Node runtime. For situations where this is not ideal, the <strong>stream responder</strong> allows
        you to send multiple chunks (i.e. write to a stream) by including your logic in a callback function.</p>

      <p>You can utilize this responder by adding a <code class="code-inline">writeStream</code> property to the
        response object and setting it to a callback function, which then accepts a <code
          class="code-inline">write()</code> function as its first and only argument.</p>

      <p><code class="code-inline">write()</code> can be called as many times as necessary to send chunks of data. Each invocation will write the passed chunk of data to the response stream. The
        response will end automatically when the callback function returns. It also optionally accepts the encoding type
        (a <code class="code-inline">string</code>) as the second argument.</p>
      <pre><code class="language-js">const { createStreamResponder } = require('tuft')

const app = tuft({
  responders: [createStreamResponder()]
})

app.set('/', () => {
  return {
    writeStream: write => {
      write('Hello, ')
      write('world!', 'UTF-8')  // Optionally set the encoding
    }
  }
})</code></pre>
    </div>
  </section>
</main>
<div class="main-margin right"></div>
