---
layout: default
permalink: /docs/extensions/
docs: true
---
<div class="main-margin left"></div>
<main id="docs">
  {% include docs_nav.html %}
  <section id="docs-content">
    <h1>Extensions</h1>
    <p>Tuft extensions are split between two types: <strong>pre-handlers</strong> and <strong>responders</strong>.</p>
    <h3 class="docs-sub-heading">Pre-handlers</h3>
    <p>A pre-handler is a function akin to a middleware function in frameworks such as <a href="https://expressjs.com"
        target="_blank">Express</a> or <a href="https://koajs.com" target="_blank">Koa</a>. A route can have an array of
      zero or more pre-handler functions which are executed serially, in insertion order, before the response handler is
      called. A <a href="/docs/api/tuft-context">TuftContext</a> object is passed as the first and only argument to each
      pre-handler. This enables you to share logic between multiple routes by writing your own pre-handler functions, or
      you can import pre-handlers from external libraries that were written by yourself or other developers.</p>

    <pre><code class="language-js">function myPreHandler(t) {
  // my custom middleware logic
}</code></pre>

    <p>To add a pre-handler to your route map, add it to an array and set that array as the value of the <code
        class="code-inline">preHandlers</code> property in your <code class="code-inline">options</code> object when you
      call <code class="code-inline">createRouteMap()</code>.</p>

    <pre><code class="language-js">const app = createRouteMap({
  preHandlers: [
    myPreHandler
  ]
})

// 'myPreHandler' will be executed before all routes added to 'app'</code></pre>

    <p>If a pre-handler returns a response object, a response will be sent based on the properties in that object, and
      all successive pre-handlers (and the main response handler itself) will be bypassed. In the following example,
      <code class="code-inline">preHandler1()</code> and <code class="code-inline">preHandler2()</code> will be
      executed, but <code class="code-inline">preHandler3()</code> and <code class="code-inline">handler()</code> will
      not:</p>

    <pre><code class="language-js">function preHandler1() {
  // custom middleware logic
}

function preHandler2() {
  return { status: 400 }
}

function preHandler3() {
  // custom middleware logic
}

function handler() {
  return { status: 200 }
}

const app = createRouteMap({
  preHandlers: [
    preHandler1,
    preHandler2,
    preHandler3
  ]
})

app.set('/', handler) // This route will return a 400 status code</code></pre>

    <p>While mofifying the passed <a href="/docs/api/tuft-context">TuftContext</a> object is supported, overriding
      pre-existing properties is not.</p>

    <pre><code class="language-js">function myPreHandler(t) {
  // 'time' is not a pre-existing property, so this is fine
  t.request.time = Date.now()

  // Don't do this, as 'secure' is a pre-existing property
  t.request.secure = true
}</code></pre>
    <p>Tuft comes packaged with the following built-in pre-handlers that you can import:</p>
    <ul class="docs-list">
      <li><a href="/docs/api/built-in-extensions.html#search-params">Search params</a></li>
      <li><a href="/docs/api/built-in-extensions.html#cookie-parser">Cookie parser</a></li>
      <li><a href="/docs/api/built-in-extensions.html#body-parser">Body parser</a></li>
    </ul>

    <h3 class="docs-sub-heading">Responders</h3>
    <p>A responder is a function that accepts a <a href="/docs/api/response-object">response object</a> and then
      optionally responds to the client based on its included data. It does this by utilizing the passed Node <a
        href="https://nodejs.org/dist/latest/docs/api/http2.html#http2_class_http2stream" target="_blank">HTTP/2
        stream</a> object.</p>

    <pre><code class="language-js">function myResponder(response, stream) {
  stream.respond()
  stream.end(response.foo)
}</code></pre>

    <blockquote>
      <p><strong>Note:</strong></p>
      <p>You should be familiar with how Node's <a
          href="https://nodejs.org/dist/latest/docs/api/http2.html#http2_core_api" target="_blank">core HTTP/2 API</a>
        works in order to write responder functions.</p>
    </blockquote>

    <p>To make use of a responder, add it to your route map by setting the <code class="code-inline">responders</code>
      option to an array and including the responder in that array. It will then be executed before Tuft's built-in
      response handling takes place.</p>

    <pre><code class="language-js">const app = createRouteMap({
  responders: [
    myResponder
  ]
})

// 'myResponder' will be executed before Tuft's built-in responders</code></pre>
    <p>Tuft comes packaged with one built-in responder that you can import:</p>
    <ul class="docs-list">
      <li><a href="/docs/api/built-in-extensions.html#stream-responder">Stream responder</a></li>
    </ul>
    <h4>How responders work</h4>
    <p>A responder receives three parameters:</p>
    <ul class="docs-list">
      <li>the response object</li>
      <li>the HTTP/2 stream object</li>
      <li>the outgoing HTTP/2 headers object</li>
    </ul>
    <p>If the responder chooses not to respond to the client, it should return the passed response object. This signals
      to the underlying framework that the response has not been sent. Otherwise, it should utilize the passed stream
      object to handle the response. The outgoing headers object will contain any of the headers that have been set by
      pre-handlers or the response handler. If any additional headers are to be added, they should be added directly to
      this object, before passing it to <code class="code-inline">stream.respond()</code>:</p>

    <pre><code class="language-js">function myResponder(response, stream, headers) {
  const { foo } = response

  if (foo) {
    headers['content-type'] = 'text/plain; charset=utf-8'
    headers['content-length'] = foo.length
    stream.respond(headers)
    stream.end(foo)
  }

  else {
    return response
  }
}</code></pre>
    <p>If there are multiple responders on a particular route, they will be executed in order until one of them fails to
      return the response object.</p>
  </section>
</main>
<div class="main-margin right"></div>
