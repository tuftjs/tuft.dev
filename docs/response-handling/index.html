---
layout: default
title: Tuft
docs: true
---
<div id="main-margin-left"></div>
<main id="main">
  {% include docs_nav.html %}
  <section id="content">
    <h1>Response handling</h1>
    <p>You can tell Tuft how to respond to a request by defining a <strong>response object</strong> as the second argument of <code class="code-inline">.set()</code>. In Tuft, a response object is just a plain JavaScript object with no required properties, so the below example is a perfectly valid route:</p>

    <pre><code class="language-js">app.set('GET /', {})</code></pre>

    <p>A response object with no properties will respond to client requests with the default HTTP status code of <code class="http-status">200 OK</code> and no response body.</p>

    <p>You can send a response body by defining one of the accepted body properties of the response object, such as <code class="code-inline">text</code>:</p>

    <pre><code class="language-js">app.set('GET /', {
  text: 'Hello, world!'
})</code></pre>

    <p>Other accepted body properties include <code class="code-inline">raw</code>, <code class="code-inline">html</code>, <code class="code-inline">json</code>, and <code class="code-inline">file</code>. For documentation on how each of these properties work, see the <a href="/docs/api/response-object">response object</a> section.</p>

    <p>Instead of passing a response object, you can also pass a function that <em>returns</em> a response object. The above example could then be written as:</p>

    <pre><code class="language-js">app.set('GET /', () => {
  const text = 'Hello, world!'
  return { text }
})</code></pre>

    <p>This is likely how most of your routes will be implemented. However, for any route where the response is known ahead of time, the first method is recommended as it may provide a significant performance improvement, especially for JSON bodies.</p>
  </section>
</main>
<div id="main-margin-right"></div>
