---
layout: default
permalink: /docs/
docs: true
---
<div class="main-margin left"></div>
<main id="docs">
  {% include docs_nav.html %}
  <section id="docs-content">
    <h1>Quick start</h1>
    <p>Tuft supports Node.js version <code class="code-inline">12</code> and higher. If you're running an earlier
      version of Node, please update before continuing.</p>
    <p>Install Tuft via <a href="https://npmjs.com" target="_blank">NPM</a>.</p>
    <pre><code class="language-shell">$ npm install tuft</code></pre>
    <p>In your application's entry point, start by importing the default exported function.</p>
    <pre><code class="language-js">const tuft = require('tuft')</code></pre>
    <p>You can then invoke it to create a Tuft "application", which allows you to add routes.</p>
    <pre><code class="language-js">const app = tuft()

app.set('GET /', {
  text: 'Hello, world!'
})</code></pre>
    <p>The above code will add a single route that responds with the text <code
        class="code-inline">'Hello, world!'</code> to any GET requests for the path <code
        class="code-inline">'/'</code>.</p>
    <p>Once you've finished adding your routes, create a server instance and call its <code
        class="code-inline">.start()</code> method.</p>
    <pre><code class="language-js">const server = app.createServer({ port: 3000 })
server.start()</code></pre>
    <p>Tuft is a promise-based framework, and the <code class="code-inline">.start()</code> method in the above code
      actually returns a promise, so you should wait for the promise to resolve if you want to know the server is
      actually running.</p>
    <pre><code class="language-js">async function startServer() {
  await server.start()
  console.log(`Server listening at http://${server.host}:${server.port}`)
}

startServer()</code></pre>

    <p>You could potentially get the same result as all the above code by chaining everything together.</p>
    <pre><code class="language-js">const tuft = require('tuft')

tuft()
  .set('GET /', {
    text: 'Hello, world!'
  })
  .createServer({ port: 3000 })
  .start()
  .then(() => {
    console.log(`Server listening at http://${server.host}:${server.port}`)
  })</code></pre>
    <p>This would ordinarily be the part where we say that if you visit <code
        class="code-inline">'http://localhost:3000'</code> in your web browser, you'll see the text <code
        class="code-inline">'Hello, world!'</code> displayed.</p>
    <p>Except... <em>you wouldn't!</em></p>
    <p>As there are no browsers known to support <em>unencrypted</em> HTTP/2 connections, you would have to use
      something like the command line client <strong>cURL</strong> to access the server in the example
      above:</p>
    <pre><code class="language-shell">$ curl --http2-prior-knowledge http://localhost:3000
Hello, world!</code></pre>
    <blockquote>
      <p>The <code class="code-inline">--http2-prior-knowledge</code> tag is only necessary for this example so that
        cURL doesn't think we're trying to access an insecure HTTP/1 server. It is not necessary when using cURL to access a
        secure HTTP/2 server.</p>
    </blockquote>
    <p>Continue to the next section, <a href="/docs/enabling-https/">Enabling HTTPS</a>, to see how to access your
      server from a
      web browser.</p>
  </section>
</main>
<div class="main-margin right"></div>
